DESIGN - BACKEND (TODO; WRITE ABT PACKAGE DEPENDENCIES)

The backend of our project was responsible for designing, implementing, and maintaining the database that supports the user-facing features of the application. This meant building a system capable of capturing user-submitted reports of possible ICE activity, storing and retrieving map pins associated with those reports, and ensuring that these two pieces of functionality remained tightly connected to the MapKit interface. A central goal was to make the map itself the primary point of interaction: when a user tapped to add or edit a pin, the backend would automatically create or update the corresponding report in the database. This required a data model flexible enough to represent user-generated content in real time while remaining simple for map rendering. 

At the start of development we prototyped using CloudKit due to its seamless integration with iOS. However, CloudKit’s reliance on users’ personal iCloud accounts created an inherent link between sensitive user submissions and identifiable Apple IDs. Because the nature of our application involves reporting immigration-related activity, maintaining strong user anonymity was a core design requirement. This led to a mid-project redesign in which we replaced CloudKit with Google Firestore. Firestore allowed us to take advantage of anonymous authentication, meaning every user could contribute data without ever sharing any  personally identifying information. Instead, the backend could associate reports with randomly generated, temporary identifiers that held no connection to users. Firestore’s real-time syncing model also suited the needs of our MapKit interface, enabling reports and pins to update instantly across the app without manual refreshes.

Much of the backend implementation focused on structuring data in a way that kept information accurate while avoiding compromising metadata. Each report stored only the essential fields: latitude, longitude, a user-provided description, and a timestamp. Similarly, each map pin—created whenever a user interacted with the map—stored only a title and coordinates, and a generated UUID. Because reports and pins are intended to reflect recent, actionable sightings, the backend only displays reports and pins that are less than four hours old, automatically filtering out older submissions during retrieval. Because tapping a pin served as the entry point for submitting or editing a report, the backend linked these two data types directly: saving a pin also triggered creation of a corresponding report in the reports database. This integration reduced opportunities for user error, prevented mismatches between reported activity and map location, and made the map a reliable real-time reflection of stored backend data.

Throughout development backend also throughly researched additional privacy-protecting technologies, such as encrypting payloads with CryptKit, location fuzzing, and removing image metadata. While these options could increase privacy, they either introduced significant complexity or compromised the accuracy required for the purpose of the app. Given the project timeline and the need to preserve geographic accuracy, we opted to focus on anonymous authentication, minimal data collection, and careful database structuring as the primary privacy safeguards. Future development would prioritize supporting image uploads while stripping EXIF metadata, and encrypting payloads with CryptKit to make it safe to begin working on push notifications for users in close proximity to a recent ICE report. 


DESIGN - MAPKIT

MapKit was a crucial part of our final project, providing the user with a feature that displays alerts on ICE spottings and allows the user to make these alerts themselves. There were three main pages that contributed to the functionaility of this feature: MapKitContentView, PinEditorView, and LocationManager. MapKitContentView serves as the hub for pin creation and display, Map View display, 







DESIGN- UI

The largest task for UI was the implementation of the Resources Page that is connected to the Navigation Bar in the app interface. The goals of the resource page was to put together contact information with various organizations in the Boston/Cambridge community that support immigrant communities through both community-building/community protection and legal services. We also wanted the page to be user-friendly and accesible while still providing ample resources and a "Know your Rights" page. The basic structure of the resources page is a list with different sections to keep the information organized with a more polished look than just a table. Each section is opened via a Naviagation Link and displays contact information for each resource. 
    
To enhance accesibibility, we had the idea of piloting a language-switch feature through the resources page. This feature, in theory, would be a toggle switch on the resource page that could switch the text displayed on the page from English text to Spanish text. We settled on Spanish translations as we felt this langauge would specifically enhance the accesibility of the app. After thorough research, pre-built Apple API's and other instant translation features, we concluded that a live translation feature such as these would not be feasible to implement with the timeline/pre-existing goals we had for the project. We still felt it was important to incorporate this feature within at least the resource page so we settled on a different method. We hard-coded Spanish translations of the English text for the resource page specifically and then implemented a toggle button feature to swtich between translations instead of live, instantaneous translations. 
    
Essentially, the button translation feature is built on a single "enumeration" or type that stores these hard-coded English and Spanish translations. Based on the toggle, the "enumeration" or "enum" can either be set to .english or .spanish. Although, this limits our project's look/functionality by not providing instantaneous translations, it is a stable method for making the app more accesible in its current stage. This feature was defintely the most difficult to implement, but is a great way to enhance accesibility, especially at this early stage of the project/while the app is still developing. 
