DESIGN - BACKEND

The backend of our project was responsible for designing, implementing, and maintaining the database that supports the user-facing features of the application. This meant building a system capable of capturing user-submitted reports of possible ICE activity, storing and retrieving map pins associated with those reports, and ensuring that these two pieces of functionality remained tightly connected to the MapKit interface. A central goal was to make the map itself the primary point of interaction: when a user tapped to add or edit a pin, the backend would automatically create or update the corresponding report in the database. This required a data model flexible enough to represent user-generated content in real time while remaining simple for map rendering. 

At the start of development we prototyped using CloudKit due to its seamless integration with iOS. However, CloudKit’s reliance on users’ personal iCloud accounts created an inherent link between sensitive user submissions and identifiable Apple IDs. Because the nature of our application involves reporting immigration-related activity, maintaining strong user anonymity was a core design requirement. This led to a mid-project redesign in which we replaced CloudKit with Google Firestore. Firestore allowed us to take advantage of anonymous authentication, meaning every user could contribute data without ever sharing any  personally identifying information. Instead, the backend could associate reports with randomly generated, temporary identifiers that held no connection to users. Firestore’s real-time syncing model also suited the needs of our MapKit interface, enabling reports and pins to update instantly across the app without manual refreshes.

Much of the backend implementation focused on structuring data in a way that kept information accurate while avoiding compromising metadata. Each report stored only the essential fields: latitude, longitude, a user-provided description, and a timestamp. Similarly, each map pin—created whenever a user interacted with the map—stored only a title and coordinates, and a generated UUID. Because reports and pins are intended to reflect recent, actionable sightings, the backend only displays reports and pins that are less than four hours old, automatically filtering out older submissions during retrieval. Because tapping a pin served as the entry point for submitting or editing a report, the backend linked these two data types directly: saving a pin also triggered creation of a corresponding report in the reports database. This integration reduced opportunities for user error, prevented mismatches between reported activity and map location, and made the map a reliable real-time reflection of stored backend data.

Throughout development backend also throughly researched additional privacy-protecting technologies, such as encrypting payloads with CryptKit, location fuzzing, and removing image metadata. While these options could increase privacy, they either introduced significant complexity or compromised the accuracy required for the purpose of the app. Given the project timeline and the need to preserve geographic accuracy, we opted to focus on anonymous authentication, minimal data collection, and careful database structuring as the primary privacy safeguards. Future development would prioritize supporting image uploads while stripping EXIF metadata, and encrypting payloads with CryptKit to make it safe to begin working on push notifications for users in close proximity to a recent ICE report. 


DESIGN - MAPKIT

MapKit was a crucial part of our final project, providing the user with a map that displays alerts on ICE spottings and allows the user to make these alerts themselves. There were three main Swift files that contributed to the functionaility of this feature: MapKitContentView, PinEditorView, and LocationManager. MapKitContentView serves as the hub for pin creation and display, Map View display- including the zoom buttons-, and a handleMapTap function that ensures a pin is not created again when a user taps on an already existing pin (a bug that occurred during testing). 

First, in MapKitContentView, I created a MapPin struct that creates the annotations, or pins that will be later added onto the map. This struct contained the variables id, title, subtitle, latitude, and longitude, all important information for the user and for the purpose of saving the pins in Firestore. The coordinates are created using CLLocationCoordinate2D, a feature of the CoreLocation framework. Every pin had an id, a UUID, to ensure that each pin could be stored in Firebase and in a MapPin array. The MapViewModel class was created to facilitate saving pins to Firebase Firestore and manage how the map presents itself. The struct MapKitContentView intializes the LocationManager object and MapViewModel object in order to use the user's location when the map is opened and the addPin function. In this same struct, there is a variable body that manages the View or the way the map looks and contains the MapReader, which allows for communication between the camera viewpoint and the map region. In the MapReader There is also a ReportService reference that takes in the information provided by the newly appended pin: the latitude, longitude and description in order to add to a Reports tab in the app. These reports are all hosted in the reports tab. To create the zoom buttons on the edge of the app screen, I utilized HStack and VStack layout containers to place the buttons exactly where I intended. The buttons were able to zoom in an out by updating the currentDistance variable (the zoom distance), and attached a label to these buttons that use images already provided by Apple - minus and plus signs - for the user to toggle zooming. The gesture used to create a pin, as written in the function handleMapTap is two taps. We decided to have two taps give the signal for creating a pin because a user's dragging of the map to explore can be interpreted as one tap and we wanted to avoid creating another pin when a user tried to tap on an already existing pin. The two tap gesture had already been loaded to indicate zoom in by SwiftUI so the zoom had to be overriden in the handleMapTap function. 

PinEditorView serves for giving form to each pin sheet, where the default title "ICE Spotting" is displayed, in addition to the description, the coordinates and the time. The subtitle, or description takes in user input, using the TextField() function, which is utilized by our application to house descriptions of the ICE spottings.

LocationManager's primary function is to handle the user's location and update the location as the user closes and opens the app, and defines the region for the location to be used in MapKitContentView. CoreLocation is imported into LocationManager and MapKitContentView to get the geographic location of the device using the app. The location permissions to this action can be found in the property list Info.plist, which asks the user for permission before using their location.







DESIGN- UI

The largest task for UI was the implementation of the Resources Page that is connected to the Navigation Bar in the app interface. The goals of the resource page was to put together contact information with various organizations in the Boston/Cambridge community that support immigrant communities through both community-building/community protection and legal services. We also wanted the page to be user-friendly and accesible while still providing ample resources and a "Know your Rights" page. The basic structure of the resources page is a list with different sections to keep the information organized with a more polished look than just a table. Each section is opened via a Naviagation Link and displays contact information for each resource. 
    
To enhance accesibibility, we had the idea of piloting a language-switch feature through the resources page. This feature, in theory, would be a toggle switch on the resource page that could switch the text displayed on the page from English text to Spanish text. We settled on Spanish translations as we felt this langauge would specifically enhance the accesibility of the app. After thorough research, pre-built Apple API's and other instant translation features, we concluded that a live translation feature such as these would not be feasible to implement with the timeline/pre-existing goals we had for the project. We still felt it was important to incorporate this feature within at least the resource page so we settled on a different method. We hard-coded Spanish translations of the English text for the resource page specifically and then implemented a toggle button feature to swtich between translations instead of live, instantaneous translations. 
    
Essentially, the button translation feature is built on a single "enumeration" or type that stores these hard-coded English and Spanish translations. Based on the toggle, the "enumeration" or "enum" can either be set to .english or .spanish. Although, this limits our project's look/functionality by not providing instantaneous translations, it is a stable method for making the app more accesible in its current stage. This feature was defintely the most difficult to implement, but is a great way to enhance accesibility, especially at this early stage of the project/while the app is still developing. 
